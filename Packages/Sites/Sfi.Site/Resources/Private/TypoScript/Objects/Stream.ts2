prototype(Sfi.Site:StreamQuery) < prototype(T:Case) {
	announcements {
		condition = ${node.properties.uriPathSegment == 'anonsy'}
		renderer = ${Search.query(site).nodeType('Sfi.Site:News').exactMatch('type', 'announcement').sortDesc('date')}
	}
	externalNews {
		condition = ${node.properties.uriPathSegment == 'obzor-smi'}
		renderer = ${Search.query(site).nodeType('Sfi.Site:News').exactMatch('type', 'externalNews').sortDesc('date')}
	}
	ourNews {
		condition = ${true}
		renderer = T:Value {
			value = ${Search.query(site).nodeType('Sfi.Site:News')}
			value.@process.filterByRelation = ${site == node ? value : value.queryFilter('bool', {should: [
				{term: {sections: node.identifier}},
				{term: {tags: node.identifier}},
				{term: {places: node.identifier}},
				{term: {projects: node.identifier}},
				{term: {collections: node.identifier}}
			]})}
			value.@process.place = ${request.arguments.place ? value.exactMatch('places', request.arguments.place) : value}
			value.@process.collection = ${request.arguments.collection ? value.exactMatch('collections', request.arguments.collection) : value}
			value.@process.filterByType = T:Case {
				photo {
					condition = ${request.arguments.media == 'isPhoto'}
					renderer = ${value.exactMatch('isPhoto', true)}
				}
				audio {
					condition = ${request.arguments.media == 'isAudio'}
					renderer = ${value.exactMatch('isAudio', true)}
				}
				video {
					condition = ${request.arguments.media == 'isVideo'}
					renderer = ${value.exactMatch('isVideo', true)}
				}
				default {
					condition = ${true}
					renderer = ${value.exactMatch('type', 'ourNews')}
				}
			}
		}
	}
}

prototype(Sfi.Site:StreamAggregations) < prototype(T:Value) {
	@context.request = 'ourNews'
	config = T:RawArray {
		filters = T:RawArray {
			filters = T:RawArray {
				isPhoto = ${{term: {isPhoto: true}}}
				isAudio = ${{term: {isAudio: true}}}
				isVideo = ${{term: {isVideo: true}}}
			}
		}
	}
	value = ${query.aggregation('media', this.config).fieldBasedAggregation('collections', 'collections')}
	value.@process.addPlaces = ${showPlaces ? value.fieldBasedAggregation('places', 'places') : value}
	value.@process.execute = ${value.execute().aggregations}
}

prototype(Sfi.Site:Stream) < prototype(T:Template) {
	templatePath = 'resource://Sfi.Site/Private/TypoScript/Objects/Stream.html'
	type = 'ourNews'
	@context.query = Sfi.Site:StreamQuery
	filterBar = T:Case {
		news {
			condition = ${q(node).property('_nodeType.name') == 'Sfi.Site:News'}
			renderer =  T:Collection {
				collection = ${q(node).property('tags') || [site]}
				itemName = 'node'
				itemRenderer = T:Tag {
					attributes.data-url = NodeUri {
						node = ${node}
					}
					attributes.class = 'filter-bar__item js-filter-bar__item'
					# akward way to fallback to all news
					content = ${q(node).property('tags') ? node.properties.title : 'все материалы'}
				}
			}
		}
		default {
			condition = ${true}
			renderer = T:Array {
				@context.aggregations = Sfi.Site:StreamAggregations
				all = T:Tag {
					attributes.class = 'filter-bar__item js-filter-bar__item'
					attributes.data-url = NodeUri {
						node = ${node}
					}
					content = 'все материалы'
					content.@process.count = ${value + ' (' + query.count() + ')'}
				}
				media = T:Collection {
					collection = ${aggregations.media.buckets}
					itemName = 'bucket'
					itemKey = 'bucketName'
					itemRenderer = T:Tag {
						@if.notEmpty = ${bucket.doc_count > 0}
						attributes.data-url = NodeUri {
							node = ${node}
							additionalParams {
								media = ${bucketName}
							}
						}
						attributes.class = 'filter-bar__item js-filter-bar__item'
						content = T:Case {
							isPhoto {
								condition = ${bucketName == 'isPhoto'}
								renderer = 'фото'
							}
							isVideo {
								condition = ${bucketName == 'isVideo'}
								renderer = 'видео'
							}
							isAudio {
								condition = ${bucketName == 'isAudio'}
								renderer = 'аудио'
							}
							@process.count = ${value + ' (' + bucket.doc_count + ')'}
						}
					}
				}
				places = T:Collection {
					collection = ${aggregations.places.buckets}
					itemName = 'bucket'
					itemRenderer = T:Tag {
						@context.node = ${q(site).find('#' + bucket.key).get(0)}
						attributes.data-url = NodeUri {
							node = ${node}
							additionalParams {
								place = ${bucket.key}
							}
						}
						attributes.data-filter-place = ${node.identifier}
						attributes.data-place-title = ${node.properties.title}
						attributes.data-place-coordinates = ${node.properties.coordinates}
						attributes.class = 'filter-bar__item js-filter-bar__item js-place'
						content = ${node.properties.title}
						content.@process.count = ${value + ' (' + bucket.doc_count + ')'}
					}
					# Set from Exhibitions
					@if.notMain = ${showPlaces ? true : false}
				}
			}
		}
	}
}

prototype(Sfi.Site:StreamAjax) < prototype(T:Value) {
	@context.itemsPerPage = 12
	@context.currentPage = ${request.arguments.currentPage ? String.toInteger(request.arguments.currentPage) : 1}
	# Used in NewsShort
	@context.isStream = ${true}
	@context.query = Sfi.Site:StreamQuery
	value = T:RawArray {
		loadMore = ${query.count() > currentPage * itemsPerPage ? true : false}
		content = T:Collection {
			collection = ${query.sortDesc('date').from((currentPage - 1) * itemsPerPage).limit(itemsPerPage).execute()}
			itemRenderer = Sfi.Site:NewsShort
		}
		@process.json = ${Json.stringify(value)}
	}
	@cache {
		mode = 'cached'
		entryTags {
			1 = 'NodeType_Sfi.Site:News'
		}
		entryIdentifier {
			node = ${node}
			pagination = ${request.arguments.currentPage}
			ajax = ${request.arguments.ajax}
			collection = ${request.arguments.collection}
			place = ${request.arguments.place}
			media = ${request.arguments.media}
			type = ${request.arguments.type}
		}
	}
}


root.stream {
	@position = 'before thePage'
	condition = ${request.arguments.ajax == 'true'}
	renderer = Sfi.Site:StreamAjax
}

root.@cache.entryIdentifier {
	node = ${node}
	pagination = ${request.arguments.currentPage}
	ajax = ${request.arguments.ajax}
	collection = ${request.arguments.collection}
	place = ${request.arguments.place}
	media = ${request.arguments.media}
	type = ${request.arguments.type}
}
